<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OnayPonay Bidding System - Secured</title>
    <style>
        :root {
            --primary-blue: #0064D2;
            --primary-green: #86B817;
            --primary-red: #E53238;
            --primary-yellow: #F5AF02;
            --primary-purple: #8c52ff;
            --primary-dark: #0f172a;
            --light-gray: #f5f7fa;
            --border: #e0e0e0;
            --card-shadow: 0 4px 12px rgba(0,0,0,0.1);
            --security-orange: #ff9800;
            --security-red: #f44336;
            --security-green: #4caf50;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #f0f7ff 0%, #f9f9f9 100%);
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: white;
            border-radius: 10px;
            box-shadow: var(--card-shadow);
            position: relative;
        }
        
        .security-badge {
            position: absolute;
            top: 20px;
            right: 20px;
            background: var(--security-green);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .header h1 {
            color: var(--primary-blue);
            margin-bottom: 10px;
        }
        
        .patent-badge {
            display: inline-block;
            background: var(--primary-purple);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
            margin: 10px 5px;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .security-panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: var(--card-shadow);
            border-left: 4px solid var(--security-orange);
        }
        
        .security-panel h2 {
            color: var(--security-orange);
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--light-gray);
        }
        
        .security-status {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .status-item {
            flex: 1;
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            background: #f9f9f9;
        }
        
        .status-active {
            background: #e8f5e9;
            color: #2e7d32;
        }
        
        .status-inactive {
            background: #ffebee;
            color: #d32f2f;
        }
        
        .panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: var(--card-shadow);
        }
        
        .panel h2 {
            color: var(--primary-blue);
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--light-gray);
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        .form-group input, .form-group select {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid var(--border);
            border-radius: 8px;
            font-size: 16px;
        }
        
        .btn {
            background: var(--primary-blue);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        
        .btn:hover {
            background: #0050a8;
        }
        
        .btn-success {
            background: var(--primary-green);
        }
        
        .btn-success:hover {
            background: #75a314;
        }
        
        .btn-danger {
            background: var(--primary-red);
        }
        
        .btn-danger:hover {
            background: #c41c1c;
        }
        
        .btn-security {
            background: var(--security-orange);
        }
        
        .btn-security:hover {
            background: #f57c00;
        }
        
        .results {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: var(--card-shadow);
            margin-top: 20px;
        }
        
        .results h2 {
            color: var(--primary-blue);
            margin-bottom: 15px;
        }
        
        .log-container {
            background: #f9f9f9;
            border-radius: 8px;
            padding: 15px;
            height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 14px;
            margin-top: 20px;
        }
        
        .log-entry {
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
        }
        
        .log-timestamp {
            color: #666;
            font-size: 12px;
        }
        
        .status-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 12px;
            margin-right: 8px;
        }
        
        .status-success {
            background: #e6f7e6;
            color: #2e7d32;
        }
        
        .status-error {
            background: #ffebee;
            color: #d32f2f;
        }
        
        .status-warning {
            background: #fff8e1;
            color: #f57c00;
        }
        
        .status-security {
            background: #e3f2fd;
            color: #1565c0;
        }
        
        .system-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .info-card {
            background: #f9f9f9;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }
        
        .info-value {
            font-size: 24px;
            font-weight: 700;
            margin: 10px 0;
        }
        
        .info-label {
            color: #666;
            font-size: 14px;
        }
        
        .free-tier-warning {
            background: #fff8e1;
            border-left: 4px solid #ffc107;
            padding: 15px;
            border-radius: 4px;
            margin-top: 20px;
        }
        
        .safeguards {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .safeguards h3 {
            color: #e65100;
            margin-bottom: 15px;
        }
        
        .mechanism {
            background: #e8f5e9;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .token-info {
            background: #e3f2fd;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .security-alert {
            background: #ffebee;
            border-left: 4px solid var(--security-red);
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
            display: none;
        }
        
        .tab-container {
            margin-top: 20px;
        }
        
        .tabs {
            display: flex;
            border-bottom: 1px solid #ddd;
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }
        
        .tab.active {
            border-bottom: 3px solid var(--primary-blue);
            font-weight: bold;
        }
        
        .tab-content {
            display: none;
            padding: 20px 0;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .security-log {
            font-family: monospace;
            font-size: 13px;
            background: #263238;
            color: #eee;
            padding: 15px;
            border-radius: 4px;
            height: 200px;
            overflow-y: auto;
            margin-top: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="security-badge">SECURED SYSTEM</div>
            <h1>OnayPonay Quantum Auction System</h1>
            <div>
                <span class="patent-badge">USPTO-63/789,465</span>
                <span class="patent-badge">USPTO-63/789,511</span>
                <span class="patent-badge">PCT/IB2024/000001</span>
            </div>
            <p>Backend Bidding System with Enhanced Security Controls</p>
        </div>
        
        <div class="dashboard">
            <div>
                <div class="security-panel">
                    <h2>Security Control Center</h2>
                    <div class="security-status">
                        <div class="status-item status-active">
                            <div>Economic Security</div>
                            <div class="info-value">ACTIVE</div>
                        </div>
                        <div class="status-item status-active">
                            <div>Anti-Collusion</div>
                            <div class="info-value">ACTIVE</div>
                        </div>
                        <div class="status-item status-inactive">
                            <div>Quantum Verification</div>
                            <div class="info-value">INACTIVE</div>
                        </div>
                    </div>
                    <div id="security-alert" class="security-alert">
                        Security alert: Suspicious activity detected!
                    </div>
                    <button class="btn btn-security" onclick="runSecurityScan()">Run Security Scan</button>
                    <button class="btn" onclick="toggleSecurityLog()">View Security Log</button>
                    
                    <div id="security-log" class="security-log" style="display: none;">
[SECURITY] System initialized with enhanced controls
[SECURITY] Economic security module loaded
[SECURITY] Anti-collusion system activated
[SECURITY] Quantum verification pending implementation
                    </div>
                </div>
                
                <div class="token-info">
                    <h3>Free Purchase Token System</h3>
                    <p>Each account receives 3 Free Purchase Tokens that provide:</p>
                    <ul>
                        <li>Infinite bidding capability in any auction</li>
                        <li>Bids don't contribute to the distribution pool</li>
                        <li>If you win, you pay your winning bid amount</li>
                        <li>After using all tokens, you need OPT tokens to bid</li>
                    </ul>
                </div>
                
                <div class="system-panel" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div class="panel">
                        <h2>Create Auction</h2>
                        <div class="form-group">
                            <label for="item-type">Item Type</label>
                            <select id="item-type">
                                <option value="replenishable">Replenishable</option>
                                <option value="unique">Unique</option>
                                <option value="industrial">Industrial</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="market-price">Market Price ($)</label>
                            <input type="number" id="market-price" value="1000">
                        </div>
                        <div class="form-group">
                            <label for="inventory">Inventory</label>
                            <input type="number" id="inventory" value="1">
                        </div>
                        <div class="form-group">
                            <label for="reserve-price">Reserve Price ($) - 50% of market by default</label>
                            <input type="number" id="reserve-price">
                        </div>
                        <button class="btn" onclick="createAuction()">Create Auction</button>
                    </div>
                    
                    <div class="panel">
                        <h2>Add Bidder</h2>
                        <div class="form-group">
                            <label for="bidder-id">Bidder ID</label>
                            <input type="text" id="bidder-id" placeholder="e.g., Alice">
                        </div>
                        <div class="form-group">
                            <label for="max-bid">Maximum Bid ($)</label>
                            <input type="number" id="max-bid" value="500">
                        </div>
                        <div class="form-group">
                            <label for="opt-balance">OPT Balance</label>
                            <input type="number" id="opt-balance" value="0">
                        </div>
                        <div class="form-group">
                            <label for="free-tokens">Free Tokens Available</label>
                            <input type="number" id="free-tokens" value="3" min="0" max="3">
                        </div>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="business-verified"> Business Verified
                            </label>
                        </div>
                        <button class="btn" onclick="addBidder()">Add Bidder</button>
                    </div>
                </div>
                
                <div class="panel">
                    <h2>Auction Management</h2>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="btn btn-success" onclick="runAuction()">Run Auction</button>
                        <button class="btn" onclick="placeBid()">Simulate Bid</button>
                        <button class="btn" onclick="useFreeToken()">Use Free Token</button>
                        <button class="btn btn-security" onclick="simulateAttack()">Simulate Attack</button>
                        <button class="btn btn-danger" onclick="resetSystem()">Reset System</button>
                    </div>
                    
                    <div class="system-info">
                        <div class="info-card">
                            <div class="info-label">Bidders Registered</div>
                            <div class="info-value" id="bidders-count">0</div>
                        </div>
                        <div class="info-card">
                            <div class="info-label">System Requests</div>
                            <div class="info-value" id="requests-count">0</div>
                        </div>
                        <div class="info-card">
                            <div class="info-label">Security Events</div>
                            <div class="info-value" id="security-events">0</div>
                        </div>
                        <div class="info-card">
                            <div class="info-label">Blocked Actions</div>
                            <div class="info-value" id="blocked-actions">0</div>
                        </div>
                    </div>
                </div>
                
                <div class="results">
                    <h2>Auction Results</h2>
                    <div id="auction-results">No auction run yet</div>
                </div>
            </div>
            
            <div>
                <div class="panel">
                    <h2>Security Monitoring</h2>
                    <div class="tab-container">
                        <div class="tabs">
                            <div class="tab active" onclick="switchTab('tab-threats')">Threat Detection</div>
                            <div class="tab" onclick="switchTab('tab-economics')">Economic Analysis</div>
                            <div class="tab" onclick="switchTab('tab-system')">System Health</div>
                        </div>
                        
                        <div id="tab-threats" class="tab-content active">
                            <h3>Recent Security Events</h3>
                            <div class="log-container" id="threat-log">
                                <div class="log-entry">
                                    <span class="log-timestamp">[12:45:30]</span>
                                    <span class="status-badge status-security">INFO</span>
                                    Security system initialized
                                </div>
                            </div>
                        </div>
                        
                        <div id="tab-economics" class="tab-content">
                            <h3>Economic Balance</h3>
                            <div class="info-card">
                                <div class="info-label">Distribution Pool</div>
                                <div class="info-value">$0.00</div>
                            </div>
                            <div class="info-card">
                                <div class="info-label">OPT Token Value</div>
                                <div class="info-value">$0.02</div>
                            </div>
                            <div class="info-card">
                                <div class="info-label">Free Tokens in Use</div>
                                <div class="info-value">0</div>
                            </div>
                        </div>
                        
                        <div id="tab-system" class="tab-content">
                            <h3>System Load</h3>
                            <div class="info-card">
                                <div class="info-label">CPU Usage</div>
                                <div class="info-value">12%</div>
                            </div>
                            <div class="info-card">
                                <div class="info-label">Memory Usage</div>
                                <div class="info-value">42MB</div>
                            </div>
                            <div class="info-card">
                                <div class="info-label">Network I/O</div>
                                <div class="info-value">0.8MB/s</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="panel">
                    <h2>Security Configuration</h2>
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="enable-price-validation" checked> Price Validation
                        </label>
                    </div>
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="enable-collusion-detection" checked> Collusion Detection
                        </label>
                    </div>
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="enable-behavior-analysis" checked> Behavior Analysis
                        </label>
                    </div>
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="enable-bid-encryption"> Bid Encryption
                        </label>
                    </div>
                    <button class="btn btn-security" onclick="applySecuritySettings()">Apply Settings</button>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <h2>System Log</h2>
            <div class="log-container" id="log-container"></div>
        </div>
    </div>

    <script>
        // Security Control Classes
        class EconomicSecurity {
            constructor() {
                this.priceOracleEnabled = true;
                this.dynamicPricingEnabled = true;
            }
            
            async validateMarketPrice(itemType, category, proposedPrice) {
                if (!this.priceOracleEnabled) return { valid: true };
                
                // Simulate fetching market data
                const marketData = await this.fetchMarketData(category);
                const avgPrice = marketData.averagePrice;
                const allowedRange = [avgPrice * 0.7, avgPrice * 1.3];
                
                if (proposedPrice < allowedRange[0] || proposedPrice > allowedRange[1]) {
                    securitySystem.logEvent(`Price validation failed: $${proposedPrice} outside acceptable range ($${allowedRange[0]} - $${allowedRange[1]})`, "WARNING");
                    return {
                        valid: false,
                        reason: `Price outside acceptable range ($${allowedRange[0]} - $${allowedRange[1]})`,
                        suggested: avgPrice
                    };
                }
                return { valid: true };
            }
            
            async fetchMarketData(category) {
                // Simulate API call to price oracle
                return new Promise(resolve => {
                    setTimeout(() => {
                        // Return mock data based on category
                        const mockData = {
                            electronics: { averagePrice: 950, range: [600, 1400] },
                            furniture: { averagePrice: 750, range: [500, 1200] },
                            industrial: { averagePrice: 5000, range: [3500, 8000] }
                        };
                        
                        resolve(mockData[category] || { averagePrice: 1000, range: [700, 1300] });
                    }, 100);
                });
            }
            
            calculateOptValue(marketConditions) {
                if (!this.dynamicPricingEnabled) return 0.02;
                
                const baseValue = 0.02;
                const demandFactor = marketConditions.demand / Math.max(marketConditions.supply, 1);
                return baseValue * (1 + (demandFactor - 1) * 0.5);
            }
        }

        class AntiCollusionSystem {
            constructor() {
                this.bidderGraph = new Map();
                this.collusionThreshold = 0.8;
                this.suspiciousBidders = new Set();
            }
            
            analyzeBiddingPatterns(auctionId, bids) {
                const patterns = this.detectSynchronizedBidding(bids);
                
                if (patterns.correlationScore > this.collusionThreshold) {
                    this.flagSuspiciousBidders(patterns.participants);
                    securitySystem.logEvent(`Collusion detected in auction ${auctionId} with score ${patterns.correlationScore.toFixed(2)}`, "ALERT");
                    return { collusionDetected: true, participants: patterns.participants };
                }
                return { collusionDetected: false };
            }
            
            detectSynchronizedBidding(bids) {
                // Simplified pattern recognition
                if (bids.length < 4) return { correlationScore: 0, participants: [] };
                
                // Analyze timing patterns
                const timingAnalysis = this.analyzeBidTiming(bids);
                
                // Analyze amount patterns
                const amountAnalysis = this.analyzeBidAmounts(bids);
                
                return {
                    correlationScore: (timingAnalysis.score + amountAnalysis.score) / 2,
                    participants: [...new Set([...timingAnalysis.suspicious, ...amountAnalysis.suspicious])]
                };
            }
            
            analyzeBidTiming(bids) {
                // Check for unusually consistent bidding intervals
                const intervals = [];
                for (let i = 1; i < bids.length; i++) {
                    const timeDiff = new Date(bids[i].timestamp) - new Date(bids[i-1].timestamp);
                    intervals.push(timeDiff);
                }
                
                // Calculate standard deviation
                const avg = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const squareDiffs = intervals.map(value => Math.pow(value - avg, 2));
                const avgSquareDiff = squareDiffs.reduce((a, b) => a + b, 0) / squareDiffs.length;
                const stdDev = Math.sqrt(avgSquareDiff);
                
                // Low standard deviation suggests automated bidding
                const score = Math.max(0, 1 - (stdDev / 10000));
                const suspicious = score > 0.7 ? bids.map(b => b.bidder_id) : [];
                
                return { score, suspicious };
            }
            
            analyzeBidAmounts(bids) {
                // Check for unusual bid amount patterns
                const amounts = bids.map(b => b.amount);
                const avg = amounts.reduce((a, b) => a + b, 0) / amounts.length;
                
                // Check if bids are just above previous bids (suggesting shill bidding)
                let incrementalCount = 0;
                for (let i = 1; i < bids.length; i++) {
                    if (bids[i].amount <= bids[i-1].amount * 1.06) {
                        incrementalCount++;
                    }
                }
                
                const incrementalRatio = incrementalCount / (bids.length - 1);
                const score = Math.min(1, incrementalRatio * 1.2);
                const suspicious = score > 0.7 ? bids.map(b => b.bidder_id) : [];
                
                return { score, suspicious };
            }
            
            flagSuspiciousBidders(bidders) {
                bidders.forEach(bidder => this.suspiciousBidders.add(bidder));
            }
            
            isSuspicious(bidderId) {
                return this.suspiciousBidders.has(bidderId);
            }
        }

        class TokenManagement {
            constructor() {
                this.deviceFingerprints = new Map();
                this.behaviorProfiles = new Map();
            }
            
            preventTokenAbuse(bidderId, action) {
                const deviceHash = this.getDeviceFingerprint();
                const behaviorProfile = this.getBehaviorProfile(bidderId);
                
                // Check for multiple accounts from same device
                const accountsFromDevice = this.getAccountsFromDevice(deviceHash);
                if (accountsFromDevice.length > 2) { // Allow 2 accounts per device
                    securitySystem.logEvent(`Multiple accounts detected from device ${deviceHash}`, "WARNING");
                    this.flagForReview(bidderId, 'multiple_accounts_same_device');
                    return false;
                }
                
                // Analyze behavior patterns
                if (this.detectArtificialPatterns(behaviorProfile)) {
                    securitySystem.logEvent(`Suspicious behavior detected for ${bidderId}`, "ALERT");
                    this.limitAccount(bidderId, 'suspicious_behavior');
                    return false;
                }
                
                return true;
            }
            
            getDeviceFingerprint() {
                // Simplified device fingerprinting
                return "device_" + Math.floor(Math.random() * 1000000);
            }
            
            getBehaviorProfile(bidderId) {
                if (!this.behaviorProfiles.has(bidderId)) {
                    this.behaviorProfiles.set(bidderId, {
                        bidFrequency: 0,
                        bidTiming: [],
                        typicalBidAmounts: []
                    });
                }
                return this.behaviorProfiles.get(bidderId);
            }
            
            getAccountsFromDevice(deviceHash) {
                // Simulate device-account mapping
                return Array.from(this.deviceFingerprints.entries())
                    .filter(([hash, accounts]) => hash === deviceHash)
                    .flatMap(([hash, accounts]) => accounts);
            }
            
            detectArtificialPatterns(profile) {
                // Check for bot-like behavior patterns
                if (profile.bidFrequency > 10) { // More than 10 bids per minute
                    return true;
                }
                
                // Check for perfectly timed bids
                if (profile.bidTiming.length > 5) {
                    const intervals = [];
                    for (let i = 1; i < profile.bidTiming.length; i++) {
                        intervals.push(profile.bidTiming[i] - profile.bidTiming[i-1]);
                    }
                    
                    const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                    const variance = intervals.map(i => Math.abs(i - avgInterval)).reduce((a, b) => a + b, 0) / intervals.length;
                    
                    if (variance < 100) { // Very consistent timing
                        return true;
                    }
                }
                
                return false;
            }
            
            flagForReview(bidderId, reason) {
                securitySystem.logEvent(`Account ${bidderId} flagged for review: ${reason}`, "WARNING");
            }
            
            limitAccount(bidderId, reason) {
                securitySystem.logEvent(`Account ${bidderId} limited: ${reason}`, "ALERT");
            }
        }

        class AuctionSecurity {
            constructor() {
                this.randomClosingEnabled = true;
                this.bidEncryptionEnabled = false;
            }
            
            ensureAuctionIntegrity(auctionId) {
                // Implement encrypted bidding if enabled
                const encryptedBids = this.bidEncryptionEnabled ? 
                    this.encryptBids(auctionId) : [];
                
                // Random closing time within last 5 minutes if enabled
                const closingTime = this.randomClosingEnabled ? 
                    this.determineClosingTime(auctionId) : null;
                
                return {
                    encrypted: this.bidEncryptionEnabled,
                    closingTime: closingTime,
                    integrityCheck: this.generateIntegrityHash(encryptedBids)
                };
            }
            
            preventBidSniping(auctionId, bids) {
                if (!this.randomClosingEnabled) return;
                
                // Auto-extend auction if last-minute bids
                const recentBids = bids.filter(bid => {
                    const bidTime = new Date(bid.timestamp);
                    const now = new Date();
                    return (now - bidTime) < 120000; // Last 2 minutes
                });
                
                if (recentBids.length > 0) {
                    securitySystem.logEvent(`Auction ${auctionId} extended due to recent bidding activity`, "INFO");
                    return true; // Indicate extension
                }
                
                return false;
            }
            
            encryptBids(auctionId) {
                // Simulate bid encryption
                securitySystem.logEvent(`Bids encrypted for auction ${auctionId}`, "INFO");
                return [];
            }
            
            determineClosingTime(auctionId) {
                // Add random extension between 0-5 minutes
                const extension = Math.floor(Math.random() * 5 * 60 * 1000);
                return new Date(Date.now() + extension).toISOString();
            }
            
            generateIntegrityHash(bids) {
                // Simulate integrity hash generation
                return "hash_" + Math.random().toString(36).substring(2, 15);
            }
        }

        class SecuritySystem {
            constructor() {
                this.economicSecurity = new EconomicSecurity();
                this.antiCollusion = new AntiCollusionSystem();
                this.tokenManagement = new TokenManagement();
                this.auctionSecurity = new AuctionSecurity();
                this.securityEvents = [];
                this.blockedActions = 0;
            }
            
            logEvent(message, level = "INFO") {
                const timestamp = new Date().toISOString();
                const entry = `[${timestamp}] [${level}] ${message}`;
                this.securityEvents.push(entry);
                
                // Update UI
                this.updateSecurityLog(entry, level);
                
                // Update counters
                if (level === "ALERT") {
                    this.blockedActions++;
                    document.getElementById('blocked-actions').textContent = this.blockedActions;
                }
                
                document.getElementById('security-events').textContent = this.securityEvents.length;
            }
            
            updateSecurityLog(entry, level) {
                const threatLog = document.getElementById('threat-log');
                const logEntry = document.createElement('div');
                logEntry.className = 'log-entry';
                
                let badgeClass = 'status-security';
                if (level === "ALERT") badgeClass = 'status-error';
                if (level === "WARNING") badgeClass = 'status-warning';
                
                logEntry.innerHTML = `
                    <span class="log-timestamp">[${new Date().toLocaleTimeString()}]</span>
                    <span class="status-badge ${badgeClass}">${level}</span>
                    ${entry.split(']').pop()}
                `;
                
                threatLog.appendChild(logEntry);
                threatLog.scrollTop = threatLog.scrollHeight;
            }
            
            async validateMarketPrice(itemType, category, proposedPrice) {
                return await this.economicSecurity.validateMarketPrice(itemType, category, proposedPrice);
            }
            
            checkForCollusion(auctionId, bids) {
                return this.antiCollusion.analyzeBiddingPatterns(auctionId, bids);
            }
            
            preventTokenAbuse(bidderId, action) {
                return this.tokenManagement.preventTokenAbuse(bidderId, action);
            }
            
            ensureAuctionIntegrity(auctionId) {
                return this.auctionSecurity.ensureAuctionIntegrity(auctionId);
            }
            
            preventBidSniping(auctionId, bids) {
                return this.auctionSecurity.preventBidSniping(auctionId, bids);
            }
            
            isSuspiciousBidder(bidderId) {
                return this.antiCollusion.isSuspicious(bidderId);
            }
        }

        // OnayPonay System Implementation with Security Integration
        class OnayPonaySystem {
            constructor() {
                this.PATENTS = {
                    "USPTO-63/789,465": "Bid-Back Pool Allocation System",
                    "USPTO-63/789,511": "Quantum Verification Mechanism",
                    "PCT/IB2024/000001": "Zero-Cost Compensation Protocol"
                };
                
                this.FREE_TIER_LIMITS = {
                    "aws_lambda": {"requests": 1000000, "compute": 400000},
                    "redis": {"storage": 30, "connections": 30},
                    "s3": {"storage": 5},
                    "bandwidth": 100
                };
                
                this.securitySystem = new SecuritySystem();
                this.reset();
            }
            
            reset() {
                this.item_type = "unique";
                this.market_price = 1000;
                this.inventory = 1;
                this.reserve = 500;
                
                this.bidders = {};
                this.transparency_log = [];
                this.system_load = {
                    "requests": 0,
                    "compute_time": 0,
                    "storage": 0.01,
                    "bandwidth": 0
                };
                
                this.quantum_security = true;
                this.zero_cost_compensation = true;
                
                this.current_highest_bid = this.reserve;
                this.current_leader = null;
                this.bidding_open = true;
                this.bid_history = [];
                this.free_bid_tracking = {};
                
                this.securitySystem.logEvent("System reset", "INFO");
            }
            
            _check_free_tier() {
                let exceeded = [];
                if (this.system_load.requests > this.FREE_TIER_LIMITS.aws_lambda.requests) {
                    exceeded.push("AWS Lambda requests");
                }
                if (this.system_load.compute_time > this.FREE_TIER_LIMITS.aws_lambda.compute) {
                    exceeded.push("Compute time");
                }
                if (this.system_load.storage > this.FREE_TIER_LIMITS.redis.storage) {
                    exceeded.push("Redis storage");
                }
                return exceeded;
            }
            
            _log_event(event) {
                const timestamp = new Date().toISOString();
                const entry = `[${timestamp}] ${event}`;
                this.transparency_log.push(entry);
                
                // Update system load
                this.system_load.requests += 1;
                this.system_load.compute_time += 0.5;
                this.system_load.bandwidth += 0.0001;
                
                // Update UI
                updateLogDisplay(entry);
                updateSystemMetrics();
                
                return entry;
            }
            
            async createAuction(item_type, market_price, inventory, reserve) {
                // Validate market price with security system
                const priceValidation = await this.securitySystem.validateMarketPrice(
                    item_type, item_type, market_price
                );
                
                if (!priceValidation.valid) {
                    this._log_event(`Price validation failed: ${priceValidation.reason}`);
                    this.securitySystem.logEvent(`Auction creation blocked: ${priceValidation.reason}`, "WARNING");
                    return {"status": "error", "message": priceValidation.reason, "suggested": priceValidation.suggested};
                }
                
                this.item_type = item_type || "unique";
                this.market_price = market_price || 1000;
                this.inventory = inventory || 1;
                this.reserve = reserve || (this.market_price * 0.5);
                
                this.bidders = {};
                this.current_highest_bid = this.reserve;
                this.current_leader = null;
                this.bidding_open = true;
                this.bid_history = [];
                this.free_bid_tracking = {};
                
                // Ensure auction integrity
                this.securitySystem.ensureAuctionIntegrity(`auction_${Date.now()}`);
                
                return this._log_event(`Auction created | Type: ${this.item_type} | Market: $${this.market_price} | Reserve: $${this.reserve}`);
            }
            
            addBidder(bidder_id, max_bid, opt_balance = 0, free_tokens = 3, business_verified = false) {
                // Check for suspicious bidders
                if (this.securitySystem.isSuspiciousBidder(bidder_id)) {
                    this._log_event(`Suspicious bidder ${bidder_id} blocked from registration`);
                    this.securitySystem.logEvent(`Bidder registration blocked for ${bidder_id} (suspicious)`, "ALERT");
                    return {"status": "error", "message": "Registration blocked for security reasons"};
                }
                
                // Check token abuse prevention
                if (!this.securitySystem.preventTokenAbuse(bidder_id, 'registration')) {
                    this._log_event(`Token abuse prevention blocked registration for ${bidder_id}`);
                    return {"status": "error", "message": "Registration blocked for security reasons"};
                }
                
                // Check storage limit
                this.system_load.storage += 0.001;
                if (this.system_load.storage > this.FREE_TIER_LIMITS.redis.storage) {
                    return {"status": "error", "message": "Storage limit exceeded"};
                }
                
                this.bidders[bidder_id] = {
                    "max_bid": max_bid || 0,
                    "credits": 0,
                    "opt_balance": opt_balance,
                    "free_tokens": free_tokens,
                    "reputation": 80,
                    "participation": 0,
                    "business_verified": business_verified,
                    "purchases_remaining": 3
                };
                
                // Initialize free bid tracking
                this.free_bid_tracking[bidder_id] = {
                    "free_bids_used": 0,
                    "last_free_bid": null
                };
                
                this._log_event(`Bidder ${bidder_id} registered | Max bid: $${max_bid} | Free tokens: ${free_tokens}`);
                return {"status": "success", "message": "Bidder added"};
            }
            
            useFreeToken(bidder_id) {
                if (!this.bidders[bidder_id]) {
                    return {"status": "error", "message": "Bidder not registered"};
                }
                
                if (this.bidders[bidder_id].free_tokens <= 0) {
                    return {"status": "error", "message": "No free tokens available"};
                }
                
                // Check for suspicious activity
                if (this.securitySystem.isSuspiciousBidder(bidder_id)) {
                    this.securitySystem.logEvent(`Free token use blocked for suspicious bidder ${bidder_id}`, "ALERT");
                    return {"status": "error", "message": "Action blocked for security reasons"};
                }
                
                // Use a free token
                this.bidders[bidder_id].free_tokens -= 1;
                this.free_bid_tracking[bidder_id].free_bids_used += 1;
                this.free_bid_tracking[bidder_id].last_free_bid = new Date().toISOString();
                
                this._log_event(`Free token used by ${bidder_id}. ${this.bidders[bidder_id].free_tokens} tokens remaining`);
                return {"status": "success", "free_tokens_remaining": this.bidders[bidder_id].free_tokens};
            }
            
            placeBid(bidder_id, bid_amount, use_free_token = false) {
                if (!this.bidding_open) {
                    return {"status": "error", "message": "Bidding is closed"};
                }
                
                if (!this.bidders[bidder_id]) {
                    return {"status": "error", "message": "Bidder not registered"};
                }
                
                // Check for suspicious bidders
                if (this.securitySystem.isSuspiciousBidder(bidder_id)) {
                    this.securitySystem.logEvent(`Bid blocked from suspicious bidder ${bidder_id}`, "ALERT");
                    return {"status": "error", "message": "Bid blocked for security reasons"};
                }
                
                // Check if bidder has available purchases or free tokens
                const has_free_tokens = this.bidders[bidder_id].free_tokens > 0;
                const has_purchases = this.bidders[bidder_id].purchases_remaining > 0;
                
                if (!has_free_tokens && !has_purchases) {
                    return {"status": "error", "message": "No purchases remaining. Buy OPT tokens."};
                }
                
                // Handle free token bidding
                if (use_free_token && has_free_tokens) {
                    const tokenResult = this.useFreeToken(bidder_id);
                    if (tokenResult.status === "error") {
                        return tokenResult;
                    }
                    // Free token bids don't contribute to the pool but can win
                    this._log_event(`FREE BID: ${bidder_id} bid $${bid_amount} using free token`);
                } else if (!has_free_tokens) {
                    // Regular bid with OPT tokens
                    const opt_required = bid_amount * 50;
                    if (this.bidders[bidder_id].opt_balance < opt_required) {
                        return {"status": "error", "message": "Insufficient OPT balance"};
                    }
                    this.bidders[bidder_id].opt_balance -= opt_required;
                }
                
                // Validate bid meets minimum requirements
                const min_bid = this.current_leader ? this.current_highest_bid * 1.05 : this.reserve;
                
                if (bid_amount < min_bid) {
                    return {
                        "status": "error", 
                        "message": `Bid must be at least $${min_bid.toFixed(2)}`,
                        "minimum_bid": min_bid
                    };
                }
                
                // For industrial equipment, check business verification
                if (this.item_type === "industrial" && !this.bidders[bidder_id].business_verified) {
                    return {"status": "error", "message": "Business verification required for industrial equipment"};
                }
                
                // Update bidder's max bid
                this.bidders[bidder_id].max_bid = Math.max(this.bidders[bidder_id].max_bid, bid_amount);
                this.bidders[bidder_id].participation += 1;
                
                // Update auction state
                this.current_highest_bid = bid_amount;
                this.current_leader = bidder_id;
                
                // Record bid history
                const bidRecord = {
                    "bidder_id": bidder_id,
                    "amount": bid_amount,
                    "timestamp": new Date().toISOString(),
                    "free_token_used": use_free_token
                };
                
                this.bid_history.push(bidRecord);
                
                // Check for bid sniping
                if (this.securitySystem.preventBidSniping(`auction_${Date.now()}`, this.bid_history)) {
                    this._log_event("Auction extended due to bid sniping protection");
                }
                
                // Log the bid
                const bid_type = use_free_token ? "free" : "opt";
                this._log_event(`Bid placed by ${bidder_id}: $${bid_amount.toFixed(2)} (${bid_type})`);
                
                return {
                    "status": "success",
                    "message": "Bid accepted",
                    "current_leading": bidder_id,
                    "current_bid": bid_amount,
                    "bid_type": bid_type
                };
            }
            
            runAuction() {
                // Check free tier limits
                const exceeded = this._check_free_tier();
                if (exceeded.length > 0) {
                    return {"status": "system_error", "reason": `Free tier exceeded: ${exceeded.join(', ')}`};
                }
                
                // Check for collusion before closing
                const collusionCheck = this.securitySystem.checkForCollusion(
                    `auction_${Date.now()}`, this.bid_history
                );
                
                if (collusionCheck.collusionDetected) {
                    this._log_event(`Collusion detected among bidders: ${collusionCheck.participants.join(', ')}`);
                    this.securitySystem.logEvent(`Auction cancelled due to collusion detection`, "ALERT");
                    
                    // Penalize colluding bidders
                    collusionCheck.participants.forEach(bidder => {
                        if (this.bidders[bidder]) {
                            this.bidders[bidder].reputation -= 30;
                            this._log_event(`Bidder ${bidder} penalized for collusion`);
                        }
                    });
                    
                    return {
                        "status": "cancelled",
                        "reason": "Collusion detected",
                        "participants": collusionCheck.participants
                    };
                }
                
                // Close bidding if still open
                if (this.bidding_open) {
                    this.bidding_open = false;
                    this._log_event("Bidding closed");
                }
                
                // Validate auction
                const valid_bids = {};
                for (const [bidder, data] of Object.entries(this.bidders)) {
                    if (data.max_bid >= this.reserve) {
                        valid_bids[bidder] = data.max_bid;
                    }
                }
                
                // Low participation protocol
                if (Object.keys(valid_bids).length < 3) {
                    this._log_event("LOW PARTICIPATION: Activating zero-cost compensation");
                    for (const bidder in this.bidders) {
                        this.bidders[bidder].credits += 500;
                        this.bidders[bidder].reputation += 10;
                        this.bidders[bidder].opt_balance += 25000; // 500 credits = 25,000 OPT
                    }
                    return this._handle_failed_auction();
                }
                
                // Run auction
                const bidders_sorted = Object.entries(valid_bids)
                    .sort((a, b) => b[1] - a[1]);
                
                const winner_id = bidders_sorted[0][0];
                const winning_bid = bidders_sorted[0][1];
                
                // Reserve verification
                if (winning_bid < this.reserve) {
                    this._log_event(`RESERVE NOT MET: $${winning_bid} < $${this.reserve}`);
                    return this._handle_failed_auction();
                }
                
                // Calculate pool (only from non-free bids + 10% commission from winner)
                let paid_losing_bids = 0;
                const losing_bidders = [];
                
                for (const [bidder, bid_amt] of bidders_sorted.slice(1)) {
                    // Only count bids that weren't made with free tokens
                    const free_bids = this.bid_history.filter(b => 
                        b.bidder_id === bidder && b.free_token_used);
                    
                    if (free_bids.length === 0) {
                        paid_losing_bids += bid_amt;
                        losing_bidders.push([bidder, bid_amt]);
                    }
                }
                
                // Winner always contributes 10% regardless of free token usage
                const pool = paid_losing_bids + (winning_bid * 0.10);
                
                // Patent-pended allocation
                let distribution;
                if (this.item_type === "replenishable" && this.inventory > 1) {
                    const runner_up = bidders_sorted[1] ? bidders_sorted[1][0] : null;
                    distribution = {
                        "onayponay": pool * 0.40,
                        "bid_credits": pool * 0.30,
                        "winner_refund": pool * 0.20,
                        "runner_up_voucher": runner_up ? pool * 0.10 : 0
                    };
                } else {
                    distribution = {
                        "onayponay": pool * 0.50,
                        "bid_credits": pool * 0.30,
                        "winner_refund": pool * 0.20,
                        "runner_up_voucher": 0
                    };
                }
                
                // Distribute benefits
                const net_cost = winning_bid - distribution.winner_refund;
                this.bidders[winner_id].reputation += 25;
                
                // Deduct purchase if not using free token
                const winner_free_bids = this.bid_history.filter(b => 
                    b.bidder_id === winner_id && b.free_token_used);
                
                if (winner_free_bids.length === 0) {
                    this.bidders[winner_id].purchases_remaining -= 1;
                }
                
                // Distribute credits only to non-free bidders
                const total_paid_losing = losing_bidders.reduce((sum, [_, bid_amt]) => sum + bid_amt, 0);
                
                for (const [bidder, bid_amt] of losing_bidders) {
                    if (bid_amt >= this.reserve) {
                        const share = total_paid_losing > 0 ? bid_amt / total_paid_losing : 0;
                        this.bidders[bidder].credits += distribution.bid_credits * share;
                        this.bidders[bidder].reputation += 5;
                        // Award OPT tokens as credits
                        const opt_credits = (distribution.bid_credits * share) * 50;
                        this.bidders[bidder].opt_balance += opt_credits;
                    }
                }
                
                // Runner-up voucher (only if not using free tokens)
                if (distribution.runner_up_voucher > 0 && bidders_sorted[1]) {
                    const runner_up = bidders_sorted[1][0];
                    const runner_up_free_bids = this.bid_history.filter(b => 
                        b.bidder_id === runner_up && b.free_token_used);
                    
                    if (runner_up_free_bids.length === 0) {
                        this.bidders[runner_up].credits += distribution.runner_up_voucher;
                        // Award OPT tokens as voucher
                        const opt_voucher = distribution.runner_up_voucher * 50;
                        this.bidders[runner_up].opt_balance += opt_voucher;
                    }
                }
                
                // Finalize
                this._log_event(`Auction succeeded | Winner: ${winner_id} | Net cost: $${net_cost.toFixed(2)}`);
                return {
                    "status": "success",
                    "winner": winner_id,
                    "winning_bid": winning_bid,
                    "net_cost": net_cost,
                    "distribution": distribution,
                    "seller_payout": winning_bid * 0.90,
                    "purchases_remaining": this.bidders[winner_id].purchases_remaining,
                    "free_token_used": winner_free_bids.length > 0
                };
            }
            
            _handle_failed_auction() {
                // Seller compensation
                const seller_benefits = {
                    "priority_relisting": true,
                    "trust_badge": "Reserve Protected",
                    "promo_slots": 3
                };
                
                // Bidder compensation
                for (const bidder in this.bidders) {
                    this.bidders[bidder].reputation += 15;
                    this.bidders[bidder].credits += 500;
                    this.bidders[bidder].opt_balance += 25000;
                }
                
                this._log_event("Compensation issued: 0$ cost");
                return {
                    "status": "failed",
                    "seller_benefits": seller_benefits,
                    "bidder_benefits": {
                        "credits_issued": 500,
                        "opt_issued": 25000,
                        "reputation_boost": 15
                    },
                    "action": "Item relisted with priority"
                };
            }
            
            simulateAttack(attackType) {
                this.securitySystem.logEvent(`Simulating ${attackType} attack`, "WARNING");
                
                switch(attackType) {
                    case "sybil":
                        // Simulate Sybil attack with multiple accounts
                        for (let i = 0; i < 5; i++) {
                            const bidderId = `sybil_${i}`;
                            this.addBidder(bidderId, 1000, 0, 3, false);
                            this.placeBid(bidderId, 600 + (i * 50), true);
                        }
                        break;
                        
                    case "collusion":
                        // Simulate collusion between bidders
                        this.addBidder("colluder1", 1000, 50000, 3, false);
                        this.addBidder("colluder2", 900, 50000, 3, false);
                        this.addBidder("colluder3", 800, 50000, 3, false);
                        
                        this.placeBid("colluder1", 600, true);
                        this.placeBid("colluder2", 610, true);
                        this.placeBid("colluder3", 620, true);
                        this.placeBid("colluder1", 630, true);
                        break;
                        
                    case "price-manipulation":
                        // Simulate price manipulation
                        this.addBidder("lowballer", 100, 0, 3, false);
                        this.placeBid("lowballer", 100, true);
                        break;
                }
                
                this._log_event(`Simulated ${attackType} attack completed`);
            }
        }

        // Initialize the system
        const onayPonaySystem = new OnayPonaySystem();
        const securitySystem = onayPonaySystem.securitySystem;

        // UI Update Functions
        function updateLogDisplay(entry) {
            const logContainer = document.getElementById('log-container');
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.innerHTML = `<span class="log-timestamp">${new Date().toLocaleTimeString()}</span> ${entry}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function updateSystemMetrics() {
            document.getElementById('bidders-count').textContent = Object.keys(onayPonaySystem.bidders).length;
            document.getElementById('requests-count').textContent = onayPonaySystem.system_load.requests;
            document.getElementById('security-events').textContent = securitySystem.securityEvents.length;
            document.getElementById('blocked-actions').textContent = securitySystem.blockedActions;
        }

        function updateResults(result) {
            const resultsDiv = document.getElementById('auction-results');
            resultsDiv.innerHTML = '';
            
            if (result.status === 'success') {
                resultsDiv.innerHTML = `
                    <div class="status-badge status-success">SUCCESS</div>
                    <p><strong>Winner:</strong> ${result.winner}</p>
                    <p><strong>Winning Bid:</strong> $${result.winning_bid.toFixed(2)}</p>
                    <p><strong>Net Cost:</strong> $${result.net_cost.toFixed(2)}</p>
                    <p><strong>Seller Payout:</strong> $${result.seller_payout.toFixed(2)}</p>
                    <p><strong>Purchases Remaining:</strong> ${result.purchases_remaining}</p>
                    <p><strong>Free Token Used:</strong> ${result.free_token_used ? 'Yes' : 'No'}</p>
                    <h3>Distribution:</h3>
                    <p>OnayPonay: $${result.distribution.onayponay.toFixed(2)}</p>
                    <p>Bid Credits: $${result.distribution.bid_credits.toFixed(2)}</p>
                    <p>Winner Refund: $${result.distribution.winner_refund.toFixed(2)}</p>
                    <p>Runner-up Voucher: $${result.distribution.runner_up_voucher.toFixed(2)}</p>
                `;
            } else if (result.status === 'failed') {
                resultsDiv.innerHTML = `
                    <div class="status-badge status-warning">FAILED</div>
                    <p>${result.action}</p>
                    <h3>Seller Benefits:</h3>
                    <p>Priority Relisting: ${result.seller_benefits.priority_relisting ? 'Yes' : 'No'}</p>
                    <p>Trust Badge: ${result.seller_benefits.trust_badge}</p>
                    <p>Promo Slots: ${result.seller_benefits.promo_slots}</p>
                    <h3>Bidder Benefits:</h3>
                    <p>Credits Issued: ${result.bidder_benefits.credits_issued}</p>
                    <p>OPT Issued: ${result.bidder_benefits.opt_issued}</p>
                    <p>Reputation Boost: +${result.bidder_benefits.reputation_boost}</p>
                `;
            } else if (result.status === 'system_error') {
                resultsDiv.innerHTML = `
                    <div class="status-badge status-error">SYSTEM ERROR</div>
                    <p>${result.reason}</p>
                `;
            } else if (result.status === 'cancelled') {
                resultsDiv.innerHTML = `
                    <div class="status-badge status-error">CANCELLED</div>
                    <p>${result.reason}</p>
                    <p>Participants: ${result.participants.join(', ')}</p>
                `;
            } else {
                resultsDiv.innerHTML = JSON.stringify(result, null, 2);
            }
        }

        // UI Action Functions
        async function createAuction() {
            const itemType = document.getElementById('item-type').value;
            const marketPrice = parseFloat(document.getElementById('market-price').value);
            const inventory = parseInt(document.getElementById('inventory').value);
            let reservePrice = parseFloat(document.getElementById('reserve-price').value);
            
            // If no reserve price specified, use 50% of market price
            if (isNaN(reservePrice)) {
                reservePrice = marketPrice * 0.5;
                document.getElementById('reserve-price').value = reservePrice;
            }
            
            const result = await onayPonaySystem.createAuction(itemType, marketPrice, inventory, reservePrice);
            
            if (result.status === 'error') {
                alert(`Error: ${result.message}. Suggested price: $${result.suggested}`);
            }
        }

        function addBidder() {
            const bidderId = document.getElementById('bidder-id').value;
            const maxBid = parseFloat(document.getElementById('max-bid').value);
            const optBalance = parseFloat(document.getElementById('opt-balance').value);
            const freeTokens = parseInt(document.getElementById('free-tokens').value);
            const businessVerified = document.getElementById('business-verified').checked;
            
            if (!bidderId) {
                alert('Please enter a bidder ID');
                return;
            }
            
            const result = onayPonaySystem.addBidder(bidderId, maxBid, optBalance, freeTokens, businessVerified);
            if (result.status === 'error') {
                alert(result.message);
            }
        }

        function runAuction() {
            const result = onayPonaySystem.runAuction();
            updateResults(result);
        }

        function placeBid() {
            const bidders = Object.keys(onayPonaySystem.bidders);
            if (bidders.length === 0) {
                alert('No bidders registered. Please add bidders first.');
                return;
            }
            
            // Select a random bidder
            const randomBidder = bidders[Math.floor(Math.random() * bidders.length)];
            
            // Generate a random bid (between current highest and bidder's max)
            const currentHighest = onayPonaySystem.current_highest_bid;
            const bidderMax = onayPonaySystem.bidders[randomBidder].max_bid;
            
            // Ensure the bid is at least 5% higher than current
            const minBid = currentHighest * 1.05;
            const maxBid = Math.max(minBid, bidderMax);
            
            if (minBid > maxBid) {
                alert(`${randomBidder} cannot bid higher than their maximum ($${bidderMax.toFixed(2)})`);
                return;
            }
            
            // Random bid between min and max
            const randomBid = minBid + (Math.random() * (maxBid - minBid));
            
            // Decide whether to use free token (if available)
            const hasFreeTokens = onayPonaySystem.bidders[randomBidder].free_tokens > 0;
            const useFreeToken = hasFreeTokens && (Math.random() > 0.5);
            
            // Place the bid
            const result = onayPonaySystem.placeBid(randomBidder, randomBid, useFreeToken);
            if (result.status === 'error') {
                alert(result.message);
            }
        }

        function useFreeToken() {
            const bidders = Object.keys(onayPonaySystem.bidders);
            if (bidders.length === 0) {
                alert('No bidders registered. Please add bidders first.');
                return;
            }
            
            // Select a random bidder with free tokens
            const biddersWithTokens = bidders.filter(bidder => 
                onayPonaySystem.bidders[bidder].free_tokens > 0);
            
            if (biddersWithTokens.length === 0) {
                alert('No bidders with free tokens available.');
                return;
            }
            
            const randomBidder = biddersWithTokens[Math.floor(Math.random() * biddersWithTokens.length)];
            
            // Use a free token
            const result = onayPonaySystem.useFreeToken(randomBidder);
            if (result.status === 'error') {
                alert(result.message);
            } else {
                alert(`${randomBidder} used a free token. ${result.free_tokens_remaining} tokens remaining.`);
            }
        }

        function resetSystem() {
            onayPonaySystem.reset();
            document.getElementById('log-container').innerHTML = '';
            document.getElementById('auction-results').textContent = 'No auction run yet';
            updateSystemMetrics();
            alert('System has been reset');
        }

        function runSecurityScan() {
            securitySystem.logEvent("Manual security scan initiated", "INFO");
            
            // Simulate security scan
            setTimeout(() => {
                securitySystem.logEvent("Security scan completed - No critical issues found", "INFO");
                alert("Security scan completed. No critical issues found.");
            }, 2000);
        }

        function toggleSecurityLog() {
            const log = document.getElementById('security-log');
            log.style.display = log.style.display === 'none' ? 'block' : 'none';
        }

        function simulateAttack() {
            const attackType = ["sybil", "collusion", "price-manipulation"][Math.floor(Math.random() * 3)];
            onayPonaySystem.simulateAttack(attackType);
            alert(`Simulating ${attackType} attack. Check security logs.`);
        }

        function switchTab(tabId) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabId).classList.add('active');
            
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.currentTarget.classList.add('active');
        }

        function applySecuritySettings() {
            const priceValidation = document.getElementById('enable-price-validation').checked;
            const collusionDetection = document.getElementById('enable-collusion-detection').checked;
            const behaviorAnalysis = document.getElementById('enable-behavior-analysis').checked;
            const bidEncryption = document.getElementById('enable-bid-encryption').checked;
            
            securitySystem.economicSecurity.priceOracleEnabled = priceValidation;
            securitySystem.antiCollusionSystem.enabled = collusionDetection;
            securitySystem.tokenManagement.enabled = behaviorAnalysis;
            securitySystem.auctionSecurity.bidEncryptionEnabled = bidEncryption;
            
            securitySystem.logEvent("Security settings updated", "INFO");
            alert("Security settings applied successfully.");
        }

        // Initialize the reserve price based on market price
        document.getElementById('market-price').addEventListener('input', function() {
            const marketPrice = parseFloat(this.value);
            if (!isNaN(marketPrice)) {
                document.getElementById('reserve-price').value = marketPrice * 0.5;
            }
        });

        // Initialize system metrics
        updateSystemMetrics();
        
        // Add sample security log entry
        securitySystem.logEvent("Security system initialized successfully", "INFO");
    </script>
</body>
</html>
